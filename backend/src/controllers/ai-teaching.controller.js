import QuizResult from '../models/QuizResult.model.js';import AIRecommendation from '../models/AIRecommendation.model.js';import Class from '../models/Class.model.js';import User from '../models/User.model.js';import aiService from '../services/ai.service.gemini.js';export const generateTeachingRecommendations = async (req, res) => {  try {    const { classId, studentId } = req.params;    const teacherId = req.user.id;    const classData = await Class.findById(classId);    if (!classData) {      return res.status(404).json({        success: false,        message: 'Class not found',      });    }    if (classData.teacher.toString() !== teacherId) {      return res.status(403).json({        success: false,        message: 'Not authorized to access this class',      });    }    const studentInClass = classData.students.some(      id => id.toString() === studentId    );    if (!studentInClass) {      return res.status(404).json({        success: false,        message: 'Student not found in this class',      });    }    const student = await User.findById(studentId);    if (!student || student.role !== 'student') {      return res.status(404).json({        success: false,        message: 'Student not found',      });    }    const quizResults = await QuizResult.find({ userId: studentId })      .populate('quizId', 'name type')      .sort({ completedAt: -1 });    const latestOceanResult = quizResults      .filter(r => r.scores)      .sort((a, b) => new Date(b.completedAt) - new Date(a.completedAt))[0] || null;    const latestLogicalResult = quizResults      .filter(r => r.correctCount !== undefined)      .sort((a, b) => new Date(b.completedAt) - new Date(a.completedAt))[0] || null;    if (!latestOceanResult && !latestLogicalResult) {      return res.status(400).json({        success: false,        message: 'Student has no quiz results yet',      });    }    let mode = 'combined';    if (latestOceanResult && !latestLogicalResult) {      mode = 'ocean_only';    } else if (!latestOceanResult && latestLogicalResult) {      mode = 'logical_only';    }    const jaRecommendations = await aiService.generateTeachingRecommendations({      studentName: student.name,      oceanResult: latestOceanResult,      logicalResult: latestLogicalResult,      language: 'ja',      mode: mode,    });    const viRecommendations = await aiService.generateTeachingRecommendations({      studentName: student.name,      oceanResult: latestOceanResult,      logicalResult: latestLogicalResult,      language: 'vi',      mode: mode,    });    res.json({      success: true,      message: 'Teaching recommendations generated successfully',      data: {        recommendations: {          ja: jaRecommendations.recommendations || [],          vi: viRecommendations.recommendations || [],        },        rawResponse: {          ja: jaRecommendations.rawResponse,          vi: viRecommendations.rawResponse,        },        personalityType: latestOceanResult?.dominantTrait,        generatedAt: new Date(),      },    });  } catch (error) {    console.error('Generate teaching recommendations error:', error);    res.status(500).json({      success: false,      message: 'Failed to generate teaching recommendations',      error: error.message,    });  }};export const generateClassTeachingRecommendations = async (req, res) => {  try {    const { classId } = req.params;    const teacherId = req.user.id;    const classData = await Class.findById(classId)      .populate('students', 'name email studentId');    if (!classData) {      return res.status(404).json({        success: false,        message: 'Class not found',      });    }    if (classData.teacher.toString() !== teacherId) {      return res.status(403).json({        success: false,        message: 'Not authorized to access this class',      });    }    const studentIds = classData.students.map(s => s._id);    const quizResults = await QuizResult.find({      userId: { $in: studentIds },    })      .populate('quizId', 'name type')      .sort({ completedAt: -1 });    const { classifyStudent } = await import('../utils/studentClassification.js');    const studentLatestResults = {};    quizResults.forEach(result => {      const userId = result.userId.toString();      if (!studentLatestResults[userId]) {        studentLatestResults[userId] = {          ocean: null,          logical: null,        };      }      if (result.quizId && result.quizId.type === 'ocean' && result.scores &&           Object.keys(result.scores).length > 0 && result.dominantTrait) {        if (!studentLatestResults[userId].ocean ||             new Date(result.completedAt) > new Date(studentLatestResults[userId].ocean.completedAt)) {          studentLatestResults[userId].ocean = result;        }      }      if (result.quizId && result.quizId.type === 'logical' && result.correctCount !== undefined) {        if (!studentLatestResults[userId].logical ||             new Date(result.completedAt) > new Date(studentLatestResults[userId].logical.completedAt)) {          studentLatestResults[userId].logical = result;        }      }    });    const oceanAverages = {      neuroticism: 0,      extraversion: 0,      openness: 0,      agreeableness: 0,      conscientiousness: 0,    };    let studentsWithOcean = 0;    Object.values(studentLatestResults).forEach(({ ocean }) => {      if (ocean && ocean.scores) {        oceanAverages.neuroticism += ocean.scores.neuroticism || 0;        oceanAverages.extraversion += ocean.scores.extraversion || 0;        oceanAverages.openness += ocean.scores.openness || 0;        oceanAverages.agreeableness += ocean.scores.agreeableness || 0;        oceanAverages.conscientiousness += ocean.scores.conscientiousness || 0;        studentsWithOcean++;      }    });    if (studentsWithOcean > 0) {      Object.keys(oceanAverages).forEach(key => {        oceanAverages[key] = Math.round(oceanAverages[key] / studentsWithOcean);      });    }    let studentsWithLogical = 0;    let logicalSum = 0;    Object.values(studentLatestResults).forEach(({ logical }) => {      if (logical) {        const percentage = logical.percentage ||           (logical.correctCount !== undefined && logical.totalQuestions !== undefined            ? Math.round((logical.correctCount / logical.totalQuestions) * 100)            : 0);        if (percentage > 0) {          logicalSum += percentage;          studentsWithLogical++;        }      }    });    const logicalAverage = studentsWithLogical > 0       ? Math.round((logicalSum / studentsWithLogical) * 100) / 100      : 0;    const classificationCounts = {      'Tự Chủ': 0,      'Dễ Áp Lực': 0,      'Sáng Tạo': 0,      'Hướng Ngoại': 0,      'Hướng Nội Phân Tích': 0,    };    Object.values(studentLatestResults).forEach(({ ocean, logical }) => {      if (ocean && ocean.scores) {        const classification = classifyStudent(ocean.scores, logical);        if (classification && classification.name && classification.name.vi) {          const classificationName = classification.name.vi;          if (classificationCounts.hasOwnProperty(classificationName)) {            classificationCounts[classificationName]++;          }        }      }    });    const totalClassified = Object.values(classificationCounts).reduce((sum, count) => sum + count, 0);    const distribution = Object.keys(classificationCounts).map(key => ({      type: key,      count: classificationCounts[key],      percentage: totalClassified > 0 ? Math.round((classificationCounts[key] / totalClassified) * 100) : 0,    })).filter(item => item.count > 0);    if (studentsWithOcean === 0 && studentsWithLogical === 0) {      return res.status(400).json({        success: false,        message: 'Class has no quiz results yet',      });    }    const jaRecommendations = await aiService.generateClassTeachingRecommendations({      className: classData.name,      oceanAverages,      logicalAverage,      distribution,      language: 'ja',    });    const viRecommendations = await aiService.generateClassTeachingRecommendations({      className: classData.name,      oceanAverages,      logicalAverage,      distribution,      language: 'vi',    });    res.json({      success: true,      message: 'Class teaching recommendations generated successfully',      data: {        recommendations: {          ja: jaRecommendations.recommendations || [],          vi: viRecommendations.recommendations || [],        },        rawResponse: {          ja: jaRecommendations.rawResponse,          vi: viRecommendations.rawResponse,        },        generatedAt: new Date(),      },    });  } catch (error) {    console.error('Generate class teaching recommendations error:', error);    res.status(500).json({      success: false,      message: 'Failed to generate class teaching recommendations',      error: error.message,    });  }};