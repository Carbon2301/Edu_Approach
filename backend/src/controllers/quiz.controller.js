import Quiz from '../models/Quiz.model.js';import Question from '../models/Question.model.js';import QuizResult from '../models/QuizResult.model.js';import AIRecommendation from '../models/AIRecommendation.model.js';import aiService from '../services/ai.service.gemini.js';import User from '../models/User.model.js';const triggerAIRecommendationGeneration = async (userId) => {  try {    const user = await User.findById(userId);    if (!user) return;    const oceanResults = await QuizResult.find({ userId })      .populate({ path: 'quizId', match: { type: 'ocean' } })      .sort({ completedAt: -1 });    const logicalResults = await QuizResult.find({ userId })      .populate({ path: 'quizId', match: { type: 'logical' } })      .sort({ completedAt: -1 });    const validOcean = oceanResults.find(r => r.quizId && r.quizId.type === 'ocean') || null;    const validLogical = logicalResults.find(r => r.quizId && r.quizId.type === 'logical') || null;    if (!validOcean && !validLogical) return;    let mode = 'combined';    if (validOcean && !validLogical) {      mode = 'ocean_only';    } else if (!validOcean && validLogical) {      mode = 'logical_only';    }    const jaRecs = await aiService.generateRecommendations({      name: user.name,      oceanResult: validOcean,      logicalResult: validLogical,      language: 'ja',      mode: mode,    });    const viRecs = await aiService.generateRecommendations({      name: user.name,      oceanResult: validOcean,      logicalResult: validLogical,      language: 'vi',      mode: mode,    });    await AIRecommendation.updateMany({ userId, isActive: true }, { isActive: false });    await AIRecommendation.create({      userId,      oceanResultId: validOcean?._id,      logicalResultId: validLogical?._id,      recommendations: {        ja: jaRecs.recommendations,        vi: viRecs.recommendations,      },      rawResponse: {        ja: jaRecs.rawResponse,        vi: viRecs.rawResponse,      },      personalityType: validOcean?.dominantTrait,      dominantTrait: validOcean?.dominantTrait,      isActive: true,    });  } catch (error) {    console.error('Auto AI generation error:', error);  }};export const getAllQuizzes = async (req, res) => {  try {    const quizzes = await Quiz.find({ isActive: true }).sort({ createdAt: -1 });    const quizzesWithStatus = await Promise.all(      quizzes.map(async (quiz) => {        const latestResult = await QuizResult.findOne({          userId: req.user.id,          quizId: quiz._id,        }).sort({ completedAt: -1 });        return {          ...quiz.toObject(),          isCompleted: !!latestResult,          lastCompletedAt: latestResult?.completedAt,        };      })    );    res.json({      success: true,      data: { quizzes: quizzesWithStatus },    });  } catch (error) {    console.error('Get quizzes error:', error);    res.status(500).json({      success: false,      message: 'Server error',      error: error.message,    });  }};export const getQuizById = async (req, res) => {  try {    const quiz = await Quiz.findById(req.params.id);    if (!quiz) {      return res.status(404).json({        success: false,        message: 'Quiz not found',      });    }    res.json({      success: true,      data: { quiz },    });  } catch (error) {    console.error('Get quiz error:', error);    res.status(500).json({      success: false,      message: 'Server error',      error: error.message,    });  }};export const getQuizQuestions = async (req, res) => {  try {    const quiz = await Quiz.findById(req.params.id);    if (!quiz) {      return res.status(404).json({        success: false,        message: 'Quiz not found',      });    }    let questions = await Question.find({ quizId: quiz._id }).sort({ questionNumber: 1 });    if (quiz.type === 'ocean' && quiz.questionsPerTake) {      const traits = ['neuroticism', 'extraversion', 'openness', 'agreeableness', 'conscientiousness'];      let selectedQuestions = [];      for (const trait of traits) {        const traitQuestions = questions.filter(q => q.traitType === trait);        const shuffled = traitQuestions.sort(() => 0.5 - Math.random());        const selected = shuffled.slice(0, 10);        selectedQuestions = selectedQuestions.concat(selected);      }      questions = selectedQuestions.sort(() => 0.5 - Math.random());    }    const questionsForClient = questions.map((q, index) => ({      _id: q._id,      questionNumber: index + 1,      questionText: q.questionText,      questionType: q.questionType,      questionImageUrl: q.questionImageUrl,      textOptions: q.textOptions,      imageOptions: q.imageOptions,    }));    res.json({      success: true,      data: {        quiz,        questions: questionsForClient,        totalQuestions: questionsForClient.length,      },    });  } catch (error) {    console.error('Get quiz questions error:', error);    res.status(500).json({      success: false,      message: 'Server error',      error: error.message,    });  }};export const submitQuiz = async (req, res) => {  try {    const { answers } = req.body; 
    const quiz = await Quiz.findById(req.params.id);    if (!quiz) {      return res.status(404).json({        success: false,        message: 'Quiz not found',      });    }    const questionIds = answers.map(a => a.questionId);    const questions = await Question.find({ _id: { $in: questionIds } });    let result;    if (quiz.type === 'ocean') {      const scores = {        neuroticism: 0,        extraversion: 0,        openness: 0,        agreeableness: 0,        conscientiousness: 0,      };      const traitCounts = {        neuroticism: 0,        extraversion: 0,        openness: 0,        agreeableness: 0,        conscientiousness: 0,      };      answers.forEach(answer => {        const question = questions.find(q => q._id.toString() === answer.questionId);        if (question && question.traitType) {          let score = answer.selectedAnswer + 1; 
          if (question.isReverseScored) {            score = 6 - score;          }          scores[question.traitType] += score;          traitCounts[question.traitType]++;        }      });      Object.keys(scores).forEach(trait => {        if (traitCounts[trait] > 0) {          const avgScore = scores[trait] / traitCounts[trait];          scores[trait] = Math.round((avgScore / 5) * 100);        }      });      const dominantTrait = Object.keys(scores).reduce((a, b) =>         scores[a] > scores[b] ? a : b      );      result = await QuizResult.create({        userId: req.user.id,        quizId: quiz._id,        answers: answers.map((a, index) => ({          questionId: a.questionId,          questionNumber: index + 1,          selectedAnswer: a.selectedAnswer,        })),        scores,        dominantTrait,        totalQuestions: answers.length,      });    } else if (quiz.type === 'logical') {      let correctCount = 0;      answers.forEach(answer => {        const question = questions.find(q => q._id.toString() === answer.questionId);        if (question && question.correctAnswer === answer.selectedAnswer) {          correctCount++;        }      });      const percentage = Math.round((correctCount / answers.length) * 100);      result = await QuizResult.create({        userId: req.user.id,        quizId: quiz._id,        answers: answers.map((a, index) => ({          questionId: a.questionId,          questionNumber: index + 1,          selectedAnswer: a.selectedAnswer,        })),        correctCount,        totalQuestions: answers.length,        percentage,      });    }    await result.populate('quizId');    triggerAIRecommendationGeneration(req.user.id).catch(err => {      console.error('Background AI generation error:', err);    });    res.json({      success: true,      message: 'Quiz submitted successfully',      data: { result },    });  } catch (error) {    console.error('Submit quiz error:', error);    res.status(500).json({      success: false,      message: 'Server error',      error: error.message,    });  }};export const getQuizResult = async (req, res) => {  try {    const result = await QuizResult.findOne({      userId: req.user.id,      quizId: req.params.id,    })      .sort({ completedAt: -1 })      .populate('quizId');    if (!result) {      return res.status(404).json({        success: false,        message: 'No results found for this quiz',      });    }    res.json({      success: true,      data: { result },    });  } catch (error) {    console.error('Get quiz result error:', error);    res.status(500).json({      success: false,      message: 'Server error',      error: error.message,    });  }};export const getAllUserResults = async (req, res) => {  try {    const results = await QuizResult.find({ userId: req.user.id })      .sort({ completedAt: -1 })      .populate('quizId');    res.json({      success: true,      data: { results },    });  } catch (error) {    console.error('Get all results error:', error);    res.status(500).json({      success: false,      message: 'Server error',      error: error.message,    });  }};