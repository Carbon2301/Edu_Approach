import User from '../models/User.model.js';import QuizResult from '../models/QuizResult.model.js';import Quiz from '../models/Quiz.model.js';import { validationResult } from 'express-validator';export const getUserProfile = async (req, res) => {  try {    const user = await User.findById(req.params.id);    if (!user) {      return res.status(404).json({        success: false,        message: 'User not found',      });    }    res.json({      success: true,      data: {        user: user.getPublicProfile(),      },    });  } catch (error) {    console.error('Get user profile error:', error);    res.status(500).json({      success: false,      message: 'Server error',      error: error.message,    });  }};export const updateProfile = async (req, res) => {  try {    const errors = validationResult(req);    if (!errors.isEmpty()) {      return res.status(400).json({         success: false,         errors: errors.array()       });    }    const { name, location, studentId, selfIntro, gender } = req.body;    const user = await User.findById(req.user.id);    if (!user) {      return res.status(404).json({        success: false,        message: 'User not found',      });    }    if (user.role === 'student' && studentId !== undefined && studentId !== user.studentId) {      const trimmedStudentId = studentId ? studentId.trim() : null;      if (trimmedStudentId) {        const existingStudentId = await User.findOne({           studentId: trimmedStudentId,          _id: { $ne: req.user.id } 
        });        if (existingStudentId) {          return res.status(400).json({            success: false,            message: 'Student ID (MSSV) already exists. Please use a different student ID.',          });        }      }    }    if (name) user.name = name;    if (location !== undefined) user.location = location;    if (user.role === 'student' && studentId !== undefined) {      user.studentId = studentId ? studentId.trim() : null;    }    if (selfIntro !== undefined) user.selfIntro = selfIntro;    if (gender !== undefined) user.gender = gender || null;    if (req.file) {      user.profileImage = `/uploads/${req.file.filename}`;    }    await user.save();    res.json({      success: true,      message: 'Profile updated successfully',      data: {        user: user.getPublicProfile(),      },    });  } catch (error) {    console.error('Update profile error:', error);    res.status(500).json({      success: false,      message: 'Server error',      error: error.message,    });  }};export const deleteProfileImage = async (req, res) => {  try {    const user = await User.findById(req.user.id);    if (!user) {      return res.status(404).json({        success: false,        message: 'User not found',      });    }    user.profileImage = null;    await user.save();    res.json({      success: true,      message: 'Profile image deleted successfully',      data: {        user: user.getPublicProfile(),      },    });  } catch (error) {    console.error('Delete profile image error:', error);    res.status(500).json({      success: false,      message: 'Server error',      error: error.message,    });  }};export const getAllUsers = async (req, res) => {  try {    const { role, search, page = 1, limit = 10 } = req.query;    const query = {};    if (role) {      query.role = role;    }    if (search) {      query.$or = [        { name: { $regex: search, $options: 'i' } },        { email: { $regex: search, $options: 'i' } },      ];    }    const users = await User.find(query)      .limit(limit * 1)      .skip((page - 1) * limit)      .sort({ createdAt: -1 });    const count = await User.countDocuments(query);    res.json({      success: true,      data: {        users: users.map(user => user.getPublicProfile()),        totalPages: Math.ceil(count / limit),        currentPage: page,        total: count,      },    });  } catch (error) {    console.error('Get all users error:', error);    res.status(500).json({      success: false,      message: 'Server error',      error: error.message,    });  }};export const getStudentDashboard = async (req, res) => {  try {    const user = await User.findById(req.user.id);    if (!user || user.role !== 'student') {      return res.status(403).json({        success: false,        message: 'Access denied. Student only.',      });    }    const quizResults = await QuizResult.find({ userId: user._id })      .populate('quizId', 'name type')      .sort({ completedAt: -1 });    const oceanResults = quizResults.filter(r => {      return r.quizId && r.quizId.type === 'ocean' && r.scores &&              Object.keys(r.scores).length > 0 && r.dominantTrait;    });    const latestOceanResult = oceanResults.length > 0      ? oceanResults.sort((a, b) => new Date(b.completedAt) - new Date(a.completedAt))[0]      : null;    const latestLogicalResult = quizResults      .filter(r => {        return r.quizId && r.quizId.type === 'logical' && r.correctCount !== undefined;      })      .sort((a, b) => new Date(b.completedAt) - new Date(a.completedAt))[0] || null;    const uniqueQuizIds = [...new Set(quizResults.map(r => r.quizId?._id?.toString()).filter(Boolean))];    const totalQuizzes = await Quiz.countDocuments({ isActive: true });    const completedQuizzes = uniqueQuizIds.length;    const { classifyStudent } = await import('../utils/studentClassification.js');    const studentClassification = classifyStudent(      latestOceanResult?.scores,      latestLogicalResult    );    res.json({      success: true,      data: {        latestOceanResult,        latestLogicalResult: latestLogicalResult || null,        completedQuizzes,        totalQuizzes,        studentClassification: studentClassification || null,      },    });  } catch (error) {    console.error('Get student dashboard error:', error);    res.status(500).json({      success: false,      message: 'Server error',      error: error.message,    });  }};